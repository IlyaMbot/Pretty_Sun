# -*- coding: utf-8 -*-
"""
Created on Tue Apr 12 00:18:47 2016

@author: Sergey
"""

from astropy.io import fits
import numpy as NP
from scipy import ndimage
from astropy import coordinates
from astropy import constants
from BadaryRAO import BadaryRAO
from scipy.optimize import least_squares

class SrhFitsFile():
    def __init__(self, name, sizeOfUv):
        self.omegaEarth = coordinates.earth.OMEGA_EARTH.to_value()
        self.isOpen = False;
        self.calibIndex = 0;
        self.frequencyChannel = 0;
        self.centerP = 0.;
        self.deltaP = 0.005;
        self.centerQ = 0.;
        self.deltaQ = 0.005;
        self.centerH = 0.;
        self.deltaH = 4.9/3600.*NP.pi;
        self.centerD = 0.;
        self.deltaD = 4.9/3600.*NP.pi;
        self.useDoubleBaselinesPhase = False
        self.useDoubleBaselinesAmp = True
        self.averageCalib = False
        self.splitEwSolution = False
        self.useNonlinearApproach = False
        self.ewLcpPhaseCorrection = NP.zeros(32)
        self.ewRcpPhaseCorrection = NP.zeros(32)
        self.sLcpPhaseCorrection = NP.zeros(16)
        self.sRcpPhaseCorrection = NP.zeros(16)
        self.badAntsLcp = NP.zeros((32, 48))
        self.badAntsRcp = NP.zeros((32, 48))
        self.fringeStopping = False
        self.phaseCalibFull = True
        self.updateAmpCalibration = True
        self.ewPhaMatrix = [ \
            [1, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1]];
        self.ewPhaMatrix2 = [ \
            [1, 0, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1], \
            [0, 1, 1, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 1, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 1, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 1, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 1, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 1, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 1, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, -1, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, -1, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, -1, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, -1, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, -1, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, -1, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, -1, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, -1]];
        self.ewAmpMatrix = [ \
            [1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1]];
        self.ewAmpMatrix2 = [ \
            [1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1], \
            [0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1]];
                             
        self.fullPhaMatrix = [ \
            [1, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1], \
            [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]];
        self.sPhaMatrix = [ \
            [1, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,-1]];
        self.sPhaMatrix2 = [ \
            [1, 0, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1], \
            [0, 1, 1, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 1, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 1, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 1, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 1, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 1, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 1, 0, -1, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, -1, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, -1, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, -1, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, -1, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, -1, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, -1, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, -1]];
        self.sAmpMatrix = [ \
            [1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1]];
        self.sAmpMatrix2 = [ \
            [1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0], \
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1], \
            [0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0], \
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1]];
        self.ewPhaseClosureMatrix = [ \
            [ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [-1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [ 0,-1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [ 0, 0,-1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [ 0, 0, 0,-1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [ 0, 0, 0, 0,-1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [ 0, 0, 0, 0, 0,-1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [ 0, 0, 0, 0, 0, 0,-1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [ 0, 0, 0, 0, 0, 0, 0,-1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [ 0, 0, 0, 0, 0, 0, 0, 0,-1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [ 0, 0, 0, 0, 0, 0, 0, 0, 0,-1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-1, 1, 0, 0, 0, 0, 0, 0, 0, 0], \
            [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-1, 1, 0, 0, 0, 0, 0, 0, 0], \
            [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-1, 1, 0, 0, 0, 0, 0, 0], \
            [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-1, 1, 0, 0, 0, 0, 0], \
            [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-1, 1, 0, 0, 0, 0], \
            [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-1, 1, 0, 0, 0], \
            [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-1, 1, 0, 0], \
            [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-1, 1, 0], \
            [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-1, 1]]

        self.sPhaseClosureMatrix = [ \
            [ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [-1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [ 0,-1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [ 0, 0,-1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [ 0, 0, 0,-1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [ 0, 0, 0, 0,-1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [ 0, 0, 0, 0, 0,-1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], \
            [ 0, 0, 0, 0, 0, 0,-1, 1, 0, 0, 0, 0, 0, 0, 0, 0], \
            [ 0, 0, 0, 0, 0, 0, 0,-1, 1, 0, 0, 0, 0, 0, 0, 0], \
            [ 0, 0, 0, 0, 0, 0, 0, 0,-1, 1, 0, 0, 0, 0, 0, 0], \
            [ 0, 0, 0, 0, 0, 0, 0, 0, 0,-1, 1, 0, 0, 0, 0, 0], \
            [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-1, 1, 0, 0, 0, 0], \
            [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-1, 1, 0, 0, 0], \
            [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-1, 1, 0, 0], \
            [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-1, 1, 0], \
            [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-1, 1]];
        self.sizeOfUv = sizeOfUv
        self.open(name)
                                    
    def open(self,name):
        try:
            self.hduList = fits.open(name);
            self.isOpen = True;
            # fitsDate = self.hduList[0].header['DATE-OBS'].split('/')
            # fitsTime = self.hduList[0].header['TIME-OBS'].split('.')
            fitsDate = self.hduList[0].header['DATE-OBS'].split('/')
            print(fitsDate)
            fitsTime = self.hduList[0].header['TIME-OBS'].split('.')
            print(fitsTime)
            fitsTime = fitsTime[0].split(':')
            print(fitsTime[0], fitsTime[1], fitsTime[2])
            self.dateObs = fitsDate[0] + '-' + fitsDate[1] + '-' + fitsDate[2] + 'T' \
                            + fitsTime[0] + ':' + fitsTime[1] + ':' + fitsTime[2]
            self.antennaNumbers = self.hduList[2].data['ANTENNA'];
            self.antennaNumbers = NP.reshape(self.antennaNumbers,self.antennaNumbers.size);
            self.antennaA = self.hduList[2].data['ANTA'];
            self.antennaA = NP.reshape(self.antennaA,self.antennaA.size);
            self.antennaB = self.hduList[2].data['ANTB'];
            self.antennaB = NP.reshape(self.antennaB,self.antennaB.size);
            self.uvLcp = NP.zeros((self.sizeOfUv,self.sizeOfUv),dtype=complex);
            self.uvRcp = NP.zeros((self.sizeOfUv,self.sizeOfUv),dtype=complex);
            self.indexA = (self.antennaA - 1)*2;
            self.indexB = (self.antennaB - 1 - 128)*2;
            self.freqList = self.hduList[1].data['FREQUENCY'];
            self.freqListLength = self.freqList.size;
            self.dataLength = self.hduList[1].data['TIME'].size // self.freqListLength;
#            self.freqTime = NP.reshape(self.hduList[1].data['TIME'],(self.freqListLength,self.dataLength));
            self.freqTime = self.hduList[1].data['TIME']
            self.visListLength = self.hduList[1].data['VIS_LCP'].size // self.freqListLength // self.dataLength;
            self.visLcp = NP.reshape(self.hduList[1].data['VIS_LCP'],(self.freqListLength,self.dataLength,self.visListLength));
            self.visRcp = NP.reshape(self.hduList[1].data['VIS_RCP'],(self.freqListLength,self.dataLength,self.visListLength));
            self.ampLcp = NP.reshape(self.hduList[1].data['AMP_LCP'],(self.freqListLength,self.dataLength,self.antennaNumbers.size));
            self.ampRcp = NP.reshape(self.hduList[1].data['AMP_RCP'],(self.freqListLength,self.dataLength,self.antennaNumbers.size));
            self.visLcp.real = NP.sin(NP.pi/2*self.visLcp.real);
            self.visRcp.real = NP.sin(NP.pi/2*self.visRcp.real);
            self.visLcp.imag = NP.sin(NP.pi/2*self.visLcp.imag);
            self.visRcp.imag = NP.sin(NP.pi/2*self.visRcp.imag);

            self.RAO = BadaryRAO(self.dateObs.split('T')[0])

        except FileNotFoundError:
            print('File %s  not found'%name);
    
    def append(self,name):
        try:
            hduList = fits.open(name);
#            freqTime = NP.reshape(self.hduList[1].data['TIME'],(self.freqListLength,self.dataLength));
            freqTime = hduList[1].data['TIME']
            dataLength = hduList[1].data['TIME'].size // self.freqListLength;
            visLcp = NP.reshape(hduList[1].data['VIS_LCP'],(self.freqListLength,dataLength,self.visListLength));
            visRcp = NP.reshape(hduList[1].data['VIS_RCP'],(self.freqListLength,dataLength,self.visListLength));
            ampLcp = NP.reshape(hduList[1].data['AMP_LCP'],(self.freqListLength,dataLength,self.antennaNumbers.size));
            ampRcp = NP.reshape(hduList[1].data['AMP_RCP'],(self.freqListLength,dataLength,self.antennaNumbers.size));
            visLcp.real = NP.sin(NP.pi/2*visLcp.real);
            visRcp.real = NP.sin(NP.pi/2*visRcp.real);
            visLcp.imag = NP.sin(NP.pi/2*visLcp.imag);
            visRcp.imag = NP.sin(NP.pi/2*visRcp.imag);

            self.freqTime = NP.concatenate((self.freqTime, freqTime), axis = 1)
            self.visLcp = NP.concatenate((self.visLcp, visLcp), axis = 1)
            self.visRcp = NP.concatenate((self.visRcp, visRcp), axis = 1)
            self.ampLcp = NP.concatenate((self.ampLcp, ampLcp), axis = 1)
            self.ampRcp = NP.concatenate((self.ampRcp, ampRcp), axis = 1)
            self.dataLength += dataLength
            hduList.close()

        except FileNotFoundError:
            print('File %s  not found'%name);

    def getHourAngle(self, scan):
        self.hAngle = self.omegaEarth * (self.freqTime[self.frequencyChannel, scan] - self.RAO.culmination)
        return self.hAngle
        
    def setSizeOfUv(self, sizeOfUv):
        self.sizeOfUv = sizeOfUv
        self.uvLcp = NP.zeros((self.sizeOfUv,self.sizeOfUv),dtype=complex);
        self.uvRcp = NP.zeros((self.sizeOfUv,self.sizeOfUv),dtype=complex);
        
    def getDeclination(self):
        return self.RAO.declination

    def getPQScale(self, size, FOV):
        self.cosP = NP.sin(self.hAngle) * NP.cos(self.RAO.declination)
        self.cosQ = NP.cos(self.hAngle) * NP.cos(self.RAO.declination) * NP.sin(self.RAO.observatory.lat) - NP.sin(self.RAO.declination) * NP.cos(self.RAO.observatory.lat)
        FOV_p = 2.*(constants.c / (self.freqList[self.frequencyChannel]*1e6)) / (self.RAO.base*NP.sqrt(1. - self.cosP**2.));
        FOV_q = 2.*(constants.c / (self.freqList[self.frequencyChannel]*1e6)) / (self.RAO.base*NP.sqrt(1. - self.cosQ**2.));
        
        return [int(size*FOV/FOV_p.to_value()), int(size*FOV/FOV_q.to_value())]
        
    def getPQ2HDMatrix(self):
        gP =  NP.arctan(NP.tan(self.hAngle)*NP.sin(self.RAO.declination));
        gQ =  NP.arctan(-(NP.sin(self.RAO.declination) / NP.tan(self.hAngle) + NP.cos(self.RAO.declination) / (NP.sin(self.hAngle)*NP.tan(self.RAO.observatory.lat))));
        
        if self.hAngle > 0:
            gQ = NP.pi + gQ;
        g = gP - gQ;
          
        pqMatrix = NP.zeros((3,3))
        pqMatrix[0, 0] =  NP.cos(gP) - NP.cos(g)*NP.cos(gQ)
        pqMatrix[0, 1] = -NP.cos(g)*NP.cos(gP) + NP.cos(gQ)
        pqMatrix[1, 0] =  NP.sin(gP) - NP.cos(g)*NP.sin(gQ)
        pqMatrix[1, 1] = -NP.cos(g)*NP.sin(gP) + NP.sin(gQ)
        pqMatrix /= NP.sin(g)**2.
        pqMatrix[2, 2] = 1.
        return pqMatrix
        
    def close(self):
        self.hduList.close();
    
    def updateAntennaAmplitude(self, average = 0, useWeights = False):
        if self.useDoubleBaselinesAmp:
            if average:
                firstScan = self.calibIndex
                if  self.visLcp.shape[1] < (self.calibIndex + average):
                    lastScan = self.dataLength
                else:
                    lastScan = self.calibIndex + average
                self.ewAmpLcp1 = NP.abs(self.visLcp[self.frequencyChannel,firstScan:lastScan,512+15:512+15+31]);
                self.ewAmpLcp1 *= NP.sqrt(self.ampLcp[self.frequencyChannel,firstScan:lastScan,16:-1]*self.ampLcp[self.frequencyChannel,firstScan:lastScan,17:])
                self.ewAmpLcp2 = NP.abs(self.visLcp[self.frequencyChannel,firstScan:lastScan,512+15+31+14:512+15+31+14+30])
                self.ewAmpLcp2 *= NP.sqrt(self.ampLcp[self.frequencyChannel,firstScan:lastScan,16:-2]*self.ampLcp[self.frequencyChannel,firstScan:lastScan,18:])
                self.ewAmpLcp = NP.append(NP.mean(self.ewAmpLcp1, axis=0), NP.mean(self.ewAmpLcp2, axis=0))
                
                self.ewAmpRcp1 = NP.abs(self.visRcp[self.frequencyChannel,firstScan:lastScan,512+15:512+15+31]);
                self.ewAmpRcp1 *= NP.sqrt(self.ampRcp[self.frequencyChannel,firstScan:lastScan,16:-1]*self.ampRcp[self.frequencyChannel,firstScan:lastScan,17:])
                self.ewAmpRcp2 = NP.abs(self.visRcp[self.frequencyChannel,firstScan:lastScan,512+15+31+14:512+15+31+14+30])
                self.ewAmpRcp2 *= NP.sqrt(self.ampRcp[self.frequencyChannel,firstScan:lastScan,16:-2]*self.ampRcp[self.frequencyChannel,firstScan:lastScan,18:])
                self.ewAmpRcp = NP.append(NP.mean(self.ewAmpRcp1, axis=0), NP.mean(self.ewAmpRcp2, axis=0))
                       
                self.sAmpLcp1  = NP.abs(self.visLcp[self.frequencyChannel,firstScan:lastScan,512:512+15]);
                self.sAmpLcp1 *= NP.sqrt(self.ampLcp[self.frequencyChannel,firstScan:lastScan,0:15]*self.ampLcp[self.frequencyChannel,firstScan:lastScan,1:16])
                self.sAmpLcp2  = NP.abs(self.visLcp[self.frequencyChannel,firstScan:lastScan,512+15+31:512+15+31+14])
                self.sAmpLcp2 *= NP.sqrt(self.ampLcp[self.frequencyChannel,firstScan:lastScan,0:14]*self.ampLcp[self.frequencyChannel,firstScan:lastScan,2:16])
                self.sAmpLcp = NP.append(NP.mean(self.sAmpLcp1, axis=0), NP.mean(self.sAmpLcp2, axis=0))
                
                self.sAmpRcp1  = NP.abs(self.visRcp[self.frequencyChannel,firstScan:lastScan,512:512+15]);
                self.sAmpRcp1 *= NP.sqrt(self.ampRcp[self.frequencyChannel,firstScan:lastScan,0:15]*self.ampRcp[self.frequencyChannel,firstScan:lastScan,1:16])
                self.sAmpRcp2  = NP.abs(self.visRcp[self.frequencyChannel,firstScan:lastScan,512+15+31:512+15+31+14])
                self.sAmpRcp2 *= NP.sqrt(self.ampRcp[self.frequencyChannel,firstScan:lastScan,0:14]*self.ampRcp[self.frequencyChannel,firstScan:lastScan,2:16])
                self.sAmpRcp = NP.append(NP.mean(self.sAmpRcp1, axis=0), NP.mean(self.sAmpRcp2, axis=0))
            else:
                self.ewAmpLcp1 = NP.abs(self.visLcp[self.frequencyChannel,self.calibIndex,512+15:512+15+31]);
                self.ewAmpLcp1 *= NP.sqrt(self.ampLcp[self.frequencyChannel,self.calibIndex,16:-1]*self.ampLcp[self.frequencyChannel,self.calibIndex,17:])
                self.ewAmpLcp2 = NP.abs(self.visLcp[self.frequencyChannel,self.calibIndex,512+15+31+14:512+15+31+14+30])
                self.ewAmpLcp2 *= NP.sqrt(self.ampLcp[self.frequencyChannel,self.calibIndex,16:-2]*self.ampLcp[self.frequencyChannel,self.calibIndex,18:])
                self.ewAmpLcp = NP.append(self.ewAmpLcp1, self.ewAmpLcp2)
                
                self.ewAmpRcp1 = NP.abs(self.visRcp[self.frequencyChannel,self.calibIndex,512+15:512+15+31]);
                self.ewAmpRcp1 *= NP.sqrt(self.ampRcp[self.frequencyChannel,self.calibIndex,16:-1]*self.ampRcp[self.frequencyChannel,self.calibIndex,17:])
                self.ewAmpRcp2 = NP.abs(self.visRcp[self.frequencyChannel,self.calibIndex,512+15+31+14:512+15+31+14+30])
                self.ewAmpRcp2 *= NP.sqrt(self.ampRcp[self.frequencyChannel,self.calibIndex,16:-2]*self.ampRcp[self.frequencyChannel,self.calibIndex,18:])
                self.ewAmpRcp = NP.append(self.ewAmpRcp1, self.ewAmpRcp2)
                       
                self.sAmpLcp1  = NP.abs(self.visLcp[self.frequencyChannel,self.calibIndex,512:512+15]);
                self.sAmpLcp1 *= NP.sqrt(self.ampLcp[self.frequencyChannel,self.calibIndex,0:15]*self.ampLcp[self.frequencyChannel,self.calibIndex,1:16])
                self.sAmpLcp2  = NP.abs(self.visLcp[self.frequencyChannel,self.calibIndex,512+15+31:512+15+31+14])
                self.sAmpLcp2 *= NP.sqrt(self.ampLcp[self.frequencyChannel,self.calibIndex,0:14]*self.ampLcp[self.frequencyChannel,self.calibIndex,2:16])
                self.sAmpLcp = NP.append(self.sAmpLcp1, self.sAmpLcp2)
                
                self.sAmpRcp1  = NP.abs(self.visRcp[self.frequencyChannel,self.calibIndex,512:512+15]);
                self.sAmpRcp1 *= NP.sqrt(self.ampRcp[self.frequencyChannel,self.calibIndex,0:15]*self.ampRcp[self.frequencyChannel,self.calibIndex,1:16])
                self.sAmpRcp2  = NP.abs(self.visRcp[self.frequencyChannel,self.calibIndex,512+15+31:512+15+31+14])
                self.sAmpRcp2 *= NP.sqrt(self.ampRcp[self.frequencyChannel,self.calibIndex,0:14]*self.ampRcp[self.frequencyChannel,self.calibIndex,2:16])
                self.sAmpRcp = NP.append(self.sAmpRcp1, self.sAmpRcp2)
            
            if useWeights:
                self.ewWeightsLcp = NP.log(1 + NP.std(self.visLcp[self.frequencyChannel,:20,512+15:512+15+31], axis = 0) / NP.mean(self.visLcp[self.frequencyChannel,:20,512+15:512+15+31], axis = 0))
                self.ewWeightsLcp = NP.append(self.ewWeightsLcp, NP.log(1 + NP.std(self.visLcp[self.frequencyChannel,:20,512+15+31+14:512+15+31+14+30], axis = 0) / NP.mean(self.visLcp[self.frequencyChannel,:20,512+15+31+14:512+15+31+14+30], axis = 0)))
                self.sWeightsLcp = NP.log(1 + NP.std(self.visLcp[self.frequencyChannel,:20,512:512+15], axis = 0) / NP.mean(self.visLcp[self.frequencyChannel,:20,512:512+15], axis = 0))
                self.sWeightsLcp = NP.append(self.sWeightsLcp, NP.log(1 + NP.std(self.visLcp[self.frequencyChannel,:20,512+15+31:512+15+31+14], axis = 0) / NP.mean(self.visLcp[self.frequencyChannel,:20,512+15+31:512+15+31+14], axis = 0)))
                
                self.ewWeightsRcp = NP.log(1 + NP.std(self.visRcp[self.frequencyChannel,:20,512+15:512+15+31], axis = 0) / NP.mean(self.visRcp[self.frequencyChannel,:20,512+15:512+15+31], axis = 0))
                self.ewWeightsRcp = NP.append(self.ewWeightsRcp, NP.log(1 + NP.std(self.visRcp[self.frequencyChannel,:20,512+15+31+14:512+15+31+14+30], axis = 0) / NP.mean(self.visRcp[self.frequencyChannel,:20,512+15+31+14:512+15+31+14+30], axis = 0)))
                self.sWeightsRcp = NP.log(1 + NP.std(self.visRcp[self.frequencyChannel,:20,512:512+15], axis = 0) / NP.mean(self.visRcp[self.frequencyChannel,:20,512:512+15], axis = 0))
                self.sWeightsRcp = NP.append(self.sWeightsRcp, NP.log(1 + NP.std(self.visRcp[self.frequencyChannel,:20,512+15+31:512+15+31+14], axis = 0) / NP.mean(self.visRcp[self.frequencyChannel,:20,512+15+31:512+15+31+14], axis = 0)))
            else:
                self.ewWeightsLcp = NP.zeros_like(self.ewAmpLcp)
                self.sWeightsLcp = NP.zeros_like(self.sAmpLcp)
                self.ewWeightsRcp = NP.zeros_like(self.ewAmpRcp)
                self.sWeightsRcp = NP.zeros_like(self.sAmpRcp)
            
            badAntsLcpEw = NP.where(self.badAntsLcp[self.frequencyChannel, 16:]==1)[0]
            badAntsLcpS = NP.where(self.badAntsLcp[self.frequencyChannel, :16]==1)[0]
            badAntsRcpEw = NP.where(self.badAntsRcp[self.frequencyChannel, 16:]==1)[0]
            badAntsRcpS =  NP.where(self.badAntsRcp[self.frequencyChannel, :16]==1)[0]
            
            if len(badAntsLcpEw) == 0:
                amp = NP.log(self.ewAmpLcp) + NP.real(self.ewWeightsLcp)
                self.ewAntAmpLcp, c, d, e = NP.linalg.lstsq(self.ewAmpMatrix2, amp, rcond=None)
                self.ewAntAmpLcp = NP.exp(self.ewAntAmpLcp[2:])
                self.ewAntAmpLcp = self.ewAntAmpLcp / NP.max(self.ewAntAmpLcp)
            else:
                self.ewAmpMatrix2_new = NP.array(self.ewAmpMatrix2)
                rows2delete = NP.where(self.ewAmpMatrix2_new[:, badAntsLcpEw+2]!=0)
                self.ewAmpMatrix2_new = NP.delete(self.ewAmpMatrix2_new, rows2delete[0], 0)
                amp = NP.log(self.ewAmpLcp) + NP.real(self.ewWeightsLcp)
                amp_new = NP.delete(amp, rows2delete[0])
                ewAntAmpLcp_new, c, d, e = NP.linalg.lstsq(self.ewAmpMatrix2_new, amp_new, rcond=None)
                self.ewAntAmpLcp = NP.exp(ewAntAmpLcp_new[2:])
                self.ewAntAmpLcp[badAntsLcpEw] = 1e6
                
            if len(badAntsLcpS) == 0:
                amp = NP.log(self.sAmpLcp) + NP.real(self.sWeightsLcp)
                self.sAntAmpLcp, c, d, e = NP.linalg.lstsq(self.sAmpMatrix2, amp, rcond=None)
                self.sAntAmpLcp  = NP.exp(self.sAntAmpLcp[2:])
                self.sAntAmpLcp  = self.sAntAmpLcp / NP.max(self.sAntAmpLcp)
            else:
                self.sAmpMatrix2_new = NP.array(self.sAmpMatrix2)
                rows2delete = NP.where(self.sAmpMatrix2_new[:, badAntsLcpS+2]!=0)
                self.sAmpMatrix2_new = NP.delete(self.sAmpMatrix2_new, rows2delete[0], 0)
                amp = NP.log(self.sAmpLcp) + NP.real(self.sWeightsLcp)
                amp_new = NP.delete(amp, rows2delete[0])
                sAntAmpLcp_new, c, d, e = NP.linalg.lstsq(self.sAmpMatrix2_new, amp_new, rcond=None)
                self.sAntAmpLcp = NP.exp(sAntAmpLcp_new[2:])
                self.sAntAmpLcp[badAntsLcpS] = 1e6
            
            if len(badAntsRcpEw) == 0:
                amp = NP.log(self.ewAmpRcp) - NP.real(self.ewWeightsRcp)
                self.ewAntAmpRcp, c, d, e = NP.linalg.lstsq(self.ewAmpMatrix2, amp, rcond=None)
                self.ewAntAmpRcp = NP.exp(self.ewAntAmpRcp[2:])
                self.ewAntAmpRcp = self.ewAntAmpRcp / NP.max(self.ewAntAmpRcp)
            else:
                self.ewAmpMatrix2_new = NP.array(self.ewAmpMatrix2)
                rows2delete = NP.where(self.ewAmpMatrix2_new[:, badAntsRcpEw+2]!=0)
                self.ewAmpMatrix2_new = NP.delete(self.ewAmpMatrix2_new, rows2delete[0], 0)
                amp = NP.log(self.ewAmpRcp) - NP.real(self.ewWeightsRcp)
                amp_new = NP.delete(amp, rows2delete[0])
                ewAntAmpRcp_new, c, d, e = NP.linalg.lstsq(self.ewAmpMatrix2_new, amp_new, rcond=None)
                self.ewAntAmpRcp = NP.exp(ewAntAmpRcp_new[2:])
                self.ewAntAmpRcp[badAntsRcpEw] = 1e6
                
            if len(badAntsRcpS) == 0:
                amp = NP.log(self.sAmpRcp) - NP.real(self.sWeightsRcp)
                self.sAntAmpRcp, c, d, e = NP.linalg.lstsq(self.sAmpMatrix2, amp, rcond=None)
                self.sAntAmpRcp  = NP.exp(self.sAntAmpRcp[2:])
                self.sAntAmpRcp  = self.sAntAmpRcp / NP.max(self.sAntAmpRcp)
            else:
                self.sAmpMatrix2_new = NP.array(self.sAmpMatrix2)
                rows2delete = NP.where(self.sAmpMatrix2_new[:, badAntsRcpS+2]!=0)
                self.sAmpMatrix2_new = NP.delete(self.sAmpMatrix2_new, rows2delete[0], 0)
                amp = NP.log(self.sAmpRcp) - NP.real(self.sWeightsRcp)
                amp_new = NP.delete(amp, rows2delete[0])
                sAntAmpRcp_new, c, d, e = NP.linalg.lstsq(self.sAmpMatrix2_new, amp_new, rcond=None)
                self.sAntAmpRcp = NP.exp(sAntAmpRcp_new[2:])
                self.sAntAmpRcp[badAntsRcpS] = 1e6
            
            
#            self.ewAntAmpLcp, c, d, e = NP.linalg.lstsq(self.ewAmpMatrix2, NP.log(self.ewAmpLcp), rcond=None)
#            self.ewAntAmpRcp, c, d, e = NP.linalg.lstsq(self.ewAmpMatrix2, NP.log(self.ewAmpRcp), rcond=None)
#    
#            self.sAntAmpLcp, c, d, e = NP.linalg.lstsq(self.sAmpMatrix2,NP.log(self.sAmpLcp), rcond=None)
#            self.sAntAmpRcp, c, d, e = NP.linalg.lstsq(self.sAmpMatrix2,NP.log(self.sAmpRcp), rcond=None)
#    
#            self.ewAntAmpLcp = NP.exp(self.ewAntAmpLcp[2:])
#            self.ewAntAmpRcp = NP.exp(self.ewAntAmpRcp[2:])
#            self.sAntAmpLcp  = NP.exp(self.sAntAmpLcp[2:])
#            self.sAntAmpRcp  = NP.exp(self.sAntAmpRcp[2:])
#    
#            self.ewAntAmpLcp = self.ewAntAmpLcp / NP.max(self.ewAntAmpLcp)
#            self.ewAntAmpRcp = self.ewAntAmpRcp / NP.max(self.ewAntAmpRcp)
#            self.sAntAmpLcp  = self.sAntAmpLcp / NP.max(self.sAntAmpLcp)
#            self.sAntAmpRcp  = self.sAntAmpRcp / NP.max(self.sAntAmpRcp)

        else:
            if average:
                firstScan = self.calibIndex
                if  self.visLcp.shape[1] < (self.calibIndex + average):
                    lastScan = self.dataLength
                else:
                    lastScan = self.calibIndex + average
                self.ewAmpLcp1 = NP.abs(self.visLcp[self.frequencyChannel,firstScan:lastScan,512+15:512+15+31]);
                self.ewAmpLcp1 *= NP.sqrt(self.ampLcp[self.frequencyChannel,firstScan:lastScan,16:-1]*self.ampLcp[self.frequencyChannel,firstScan:lastScan,17:])
                self.ewAmpLcp = NP.mean(self.ewAmpLcp1, axis=0)
                
                self.ewAmpRcp1 = NP.abs(self.visRcp[self.frequencyChannel,firstScan:lastScan,512+15:512+15+31]);
                self.ewAmpRcp1 *= NP.sqrt(self.ampRcp[self.frequencyChannel,firstScan:lastScan,16:-1]*self.ampRcp[self.frequencyChannel,firstScan:lastScan,17:])
                self.ewAmpRcp = NP.mean(self.ewAmpRcp1, axis=0)
                       
                self.sAmpLcp1  = NP.abs(self.visLcp[self.frequencyChannel,firstScan:lastScan,512:512+15]);
                self.sAmpLcp1 *= NP.sqrt(self.ampLcp[self.frequencyChannel,firstScan:lastScan,0:15]*self.ampLcp[self.frequencyChannel,firstScan:lastScan,1:16])
                self.sAmpLcp = NP.mean(self.sAmpLcp1, axis=0)
                
                self.sAmpRcp1  = NP.abs(self.visRcp[self.frequencyChannel,firstScan:lastScan,512:512+15]);
                self.sAmpRcp1 *= NP.sqrt(self.ampRcp[self.frequencyChannel,firstScan:lastScan,0:15]*self.ampRcp[self.frequencyChannel,firstScan:lastScan,1:16])
                self.sAmpRcp = NP.mean(self.sAmpRcp1, axis=0)
            else:
                self.ewAmpLcp = NP.abs(self.visLcp[self.frequencyChannel,self.calibIndex,512+15:512+15+31]);
                self.ewAmpRcp = NP.abs(self.visRcp[self.frequencyChannel,self.calibIndex,512+15:512+15+31]);
                self.sAmpLcp  = NP.abs(self.visLcp[self.frequencyChannel,self.calibIndex,512:512+15]);
                self.sAmpRcp  = NP.abs(self.visRcp[self.frequencyChannel,self.calibIndex,512:512+15]);
        
                self.ewAmpLcp *= NP.sqrt(self.ampLcp[self.frequencyChannel,self.calibIndex,16:-1]*self.ampLcp[self.frequencyChannel,self.calibIndex,17:])
                self.ewAmpRcp *= NP.sqrt(self.ampRcp[self.frequencyChannel,self.calibIndex,16:-1]*self.ampRcp[self.frequencyChannel,self.calibIndex,17:])
                self.sAmpLcp *= NP.sqrt(self.ampLcp[self.frequencyChannel,self.calibIndex,0:15]*self.ampLcp[self.frequencyChannel,self.calibIndex,1:16])
                self.sAmpRcp *= NP.sqrt(self.ampRcp[self.frequencyChannel,self.calibIndex,0:15]*self.ampRcp[self.frequencyChannel,self.calibIndex,1:16])
            
            if self.splitEwSolution:
                self.ewAntAmpLcp0, c, d, e = NP.linalg.lstsq(self.sAmpMatrix,NP.log(self.ewAmpLcp[0:15]))
                self.ewAntAmpRcp0, c, d, e = NP.linalg.lstsq(self.sAmpMatrix,NP.log(self.ewAmpRcp[0:15]))
                self.ewAntAmpLcp1, c, d, e = NP.linalg.lstsq(self.sAmpMatrix,NP.log(self.ewAmpLcp[16:31]))
                self.ewAntAmpRcp1, c, d, e = NP.linalg.lstsq(self.sAmpMatrix,NP.log(self.ewAmpRcp[16:31]))
                
                self.ewAntAmpLcp = NP.zeros(33)
                self.ewAntAmpRcp = NP.zeros(33)
                self.ewAntAmpLcp[1:16] = self.ewAntAmpLcp0[1:16]
                self.ewAntAmpLcp[17:32] = self.ewAntAmpLcp1[1:16]
                self.ewAntAmpRcp[1:16] = self.ewAntAmpRcp0[1:16]
                self.ewAntAmpRcp[17:32] = self.ewAntAmpRcp1[1:16]
            else:
                self.ewAntAmpLcp, c, d, e = NP.linalg.lstsq(self.ewAmpMatrix,NP.log(self.ewAmpLcp), rcond=None)
                self.ewAntAmpRcp, c, d, e = NP.linalg.lstsq(self.ewAmpMatrix,NP.log(self.ewAmpRcp), rcond=None)
                
            self.sAntAmpLcp, c, d, e = NP.linalg.lstsq(self.sAmpMatrix,NP.log(self.sAmpLcp), rcond=None)
            self.sAntAmpRcp, c, d, e = NP.linalg.lstsq(self.sAmpMatrix,NP.log(self.sAmpRcp), rcond=None)
            
            self.ewAntAmpLcp = NP.exp(self.ewAntAmpLcp[1:])
            self.ewAntAmpRcp = NP.exp(self.ewAntAmpRcp[1:])
            self.sAntAmpLcp  = NP.exp(self.sAntAmpLcp[1:])
            self.sAntAmpRcp  = NP.exp(self.sAntAmpRcp[1:])
    
            self.ewAntAmpLcp = self.ewAntAmpLcp / NP.max(self.ewAntAmpLcp)
            self.ewAntAmpRcp = self.ewAntAmpRcp / NP.max(self.ewAntAmpRcp)
            self.sAntAmpLcp  = self.sAntAmpLcp / NP.max(self.sAntAmpLcp)
            self.sAntAmpRcp  = self.sAntAmpRcp / NP.max(self.sAntAmpRcp)
            
    def updateAntennaPhase(self, average = 0):
        if self.useDoubleBaselinesPhase:
            self.ewPhaLcp1 = NP.angle(self.visLcp[self.frequencyChannel,self.calibIndex,512+15:512+15+31]);
            self.ewPhaLcp2 = NP.angle(self.visLcp[self.frequencyChannel,self.calibIndex,512+15+31+14:512+15+31+14+30])
            self.ewPhaLcp = NP.unwrap(NP.append(self.ewPhaLcp1, self.ewPhaLcp2))
            self.ewPhaRcp1 = NP.angle(self.visRcp[self.frequencyChannel,self.calibIndex,512+15:512+15+31]);
            self.ewPhaRcp2 = NP.angle(self.visRcp[self.frequencyChannel,self.calibIndex,512+15+31+14:512+15+31+14+30])
            self.ewPhaRcp = NP.unwrap(NP.append(self.ewPhaRcp1, self.ewPhaRcp2))
            
            self.sPhaLcp1  = NP.angle(self.visLcp[self.frequencyChannel,self.calibIndex,512:512+15]);
            self.sPhaLcp2  = NP.angle(self.visLcp[self.frequencyChannel,self.calibIndex,512+15+31:512+15+31+14]);
            self.sPhaLcp = NP.unwrap(NP.append(self.sPhaLcp1, self.sPhaLcp2))
            self.sPhaRcp1  = NP.angle(self.visRcp[self.frequencyChannel,self.calibIndex,512:512+15]);
            self.sPhaRcp2  = NP.angle(self.visRcp[self.frequencyChannel,self.calibIndex,512+15+31:512+15+31+14]);
            self.sPhaRcp = NP.unwrap(NP.append(self.sPhaRcp1, self.sPhaRcp2))
    
            self.ewAntPhaLcp, c, d, e = NP.linalg.lstsq(self.ewPhaMatrix2,self.ewPhaLcp, rcond=None);
            self.sAntPhaLcp, c, d, e = NP.linalg.lstsq(self.sPhaMatrix2,self.sPhaLcp, rcond=None);
            self.ewAntPhaRcp, c, d, e = NP.linalg.lstsq(self.ewPhaMatrix2,self.ewPhaRcp, rcond=None);
            self.sAntPhaRcp, c, d, e = NP.linalg.lstsq(self.sPhaMatrix2,self.sPhaRcp, rcond=None);
            
            self.ewAntPhaLcp = self.ewAntPhaLcp[2:]
            self.sAntPhaLcp = self.sAntPhaLcp[2:]
            self.ewAntPhaRcp = self.ewAntPhaRcp[2:]
            self.sAntPhaRcp = self.sAntPhaRcp[2:]
        
        else:
            if average:
                firstScan = self.calibIndex
                if  self.visLcp.shape[1] < (self.calibIndex + average):
                    lastScan = self.dataLength
                else:
                    lastScan = self.calibIndex + average
                self.ewPhaLcp = NP.angle(NP.mean(self.visLcp[self.frequencyChannel,firstScan:lastScan,512+15:512+15+31], axis = 0));
                self.ewPhaRcp = NP.angle(NP.mean(self.visRcp[self.frequencyChannel,firstScan:lastScan,512+15:512+15+31], axis = 0));
                self.sPhaLcp  = NP.angle(NP.mean(self.visLcp[self.frequencyChannel,firstScan:lastScan,512:512+15], axis = 0));
                self.sPhaRcp  = NP.angle(NP.mean(self.visRcp[self.frequencyChannel,firstScan:lastScan,512:512+15], axis = 0));
            else:
                self.ewPhaLcp = NP.angle(self.visLcp[self.frequencyChannel,self.calibIndex,512+15:512+15+31]);
                self.ewPhaRcp = NP.angle(self.visRcp[self.frequencyChannel,self.calibIndex,512+15:512+15+31]);
                self.sPhaLcp  = NP.angle(self.visLcp[self.frequencyChannel,self.calibIndex,512:512+15]);
                self.sPhaRcp  = NP.angle(self.visRcp[self.frequencyChannel,self.calibIndex,512:512+15]);
    
            self.ewAntPhaLcp, c, d, e = NP.linalg.lstsq(self.ewPhaMatrix,self.ewPhaLcp, rcond=None);
            self.sAntPhaLcp, c, d, e = NP.linalg.lstsq(self.sPhaMatrix,self.sPhaLcp, rcond=None);
            self.ewAntPhaRcp, c, d, e = NP.linalg.lstsq(self.ewPhaMatrix,self.ewPhaRcp, rcond=None);
            self.sAntPhaRcp, c, d, e = NP.linalg.lstsq(self.sPhaMatrix,self.sPhaRcp, rcond=None);
            
            self.ewAntPhaLcp = self.ewAntPhaLcp[1:]
            self.sAntPhaLcp = self.sAntPhaLcp[1:]
            self.ewAntPhaRcp = self.ewAntPhaRcp[1:]
            self.sAntPhaRcp = self.sAntPhaRcp[1:]
            
    def updateAntennaPhaseFull(self, average = 0):
        
        if average:
            firstScan = self.calibIndex
            if  self.visLcp.shape[1] < (self.calibIndex + average):
                lastScan = self.dataLength
            else:
                lastScan = self.calibIndex + average
            self.ewPhaLcp = NP.angle(NP.mean(self.visLcp[self.frequencyChannel,firstScan:lastScan,512+15:512+15+31], axis = 0));
            self.ewPhaRcp = NP.angle(NP.mean(self.visRcp[self.frequencyChannel,firstScan:lastScan,512+15:512+15+31], axis = 0));
            self.sPhaLcp  = NP.angle(NP.mean(self.visLcp[self.frequencyChannel,firstScan:lastScan,512:512+15], axis = 0));
            self.sPhaRcp  = NP.angle(NP.mean(self.visRcp[self.frequencyChannel,firstScan:lastScan,512:512+15], axis = 0));
            phaLcp_64_192 = NP.angle(NP.mean(self.visLcp[self.frequencyChannel,firstScan:lastScan,15], axis = 0))
            phaRcp_64_192 = NP.angle(NP.mean(self.visRcp[self.frequencyChannel,firstScan:lastScan,15], axis = 0))
        else:
            self.ewPhaLcp = NP.angle(self.visLcp[self.frequencyChannel,self.calibIndex,512+15:512+15+31]);
            self.ewPhaRcp = NP.angle(self.visRcp[self.frequencyChannel,self.calibIndex,512+15:512+15+31]);
            self.sPhaLcp  = NP.angle(self.visLcp[self.frequencyChannel,self.calibIndex,512:512+15]);
            self.sPhaRcp  = NP.angle(self.visRcp[self.frequencyChannel,self.calibIndex,512:512+15]);
            phaLcp_64_192 = NP.angle(self.visLcp[self.frequencyChannel,self.calibIndex,15])
            phaRcp_64_192 = NP.angle(self.visRcp[self.frequencyChannel,self.calibIndex,15])
            
        self.phaLcp = NP.concatenate((self.ewPhaLcp, self.sPhaLcp, NP.array((phaLcp_64_192,0,0,0))))
        self.phaRcp = NP.concatenate((self.ewPhaRcp, self.sPhaRcp, NP.array((phaRcp_64_192,0,0,0))))

        self.antPhaLcp, c, d, e = NP.linalg.lstsq(self.fullPhaMatrix,self.phaLcp, rcond=None);
        self.antPhaRcp, c, d, e = NP.linalg.lstsq(self.fullPhaMatrix,self.phaRcp, rcond=None);
        
        self.ewAntPhaLcp = self.antPhaLcp[3:35]
        self.sAntPhaLcp = self.antPhaLcp[35:]
        self.ewAntPhaRcp = self.antPhaRcp[3:35]
        self.sAntPhaRcp = self.antPhaRcp[35:]
            
            
    def sGainsFunc(self, x, obsVis1, obsVis2):
        N = len(x)//2
        res = NP.zeros(29, dtype = complex)
        solVis1 = x[0] + x[N]*1j
        solVis2 = x[1] + x[N+1]*1j
        gains = x[2:N] + x[N+2:]*1j
        for i in range(15):
            res[i] = solVis1 * gains[i] * NP.conj(gains[i+1]) - obsVis1[i]
        for i in range(14):
            res[i+15] = solVis2 * gains[i] * NP.conj(gains[i+2]) - obsVis2[i]
        return NP.concatenate((res.real, res.imag))

    def ewGainsFunc(self, x, obsVis1, obsVis2):
        res = NP.zeros(61, dtype = complex)
        N = len(x)//2
        solVis1 = x[0] + x[N]*1j
        solVis2 = x[1] + x[N+1]*1j
        gains = x[2:N] + x[N+2:]*1j
        for i in range(31):
            res[i] = solVis1 * gains[i] * NP.conj(gains[i+1]) - obsVis1[i]
        for i in range(30):
            res[i+31] = solVis2 * gains[i] * NP.conj(gains[i+2]) - obsVis2[i]
        return NP.concatenate((res.real, res.imag))
    
    def updateSGains(self):
        x_ini = NP.concatenate((NP.ones(18), NP.zeros(18)))
        vis_l_1 = self.visLcp[self.frequencyChannel,self.calibIndex,512:512+15].copy()
        vis_l_2 = self.visLcp[self.frequencyChannel,self.calibIndex,512+15+31:512+15+31+14].copy()
        vis_l_1 *= NP.sqrt(self.ampLcp[self.frequencyChannel,self.calibIndex,0:15]*self.ampLcp[self.frequencyChannel,self.calibIndex,1:16])
        vis_l_2 *= NP.sqrt(self.ampLcp[self.frequencyChannel,self.calibIndex,0:14]*self.ampLcp[self.frequencyChannel,self.calibIndex,2:16])
        ls_res = least_squares(self.sGainsFunc, x_ini, args = (vis_l_1, vis_l_2))
        sGainsLcp = ls_res['x'][2:18] + ls_res['x'][20:]*1j
        self.sAntPhaLcp = NP.angle(sGainsLcp)
        self.sAntAmpLcp = NP.abs(sGainsLcp)
        
        vis_r_1 = self.visRcp[self.frequencyChannel,self.calibIndex,512:512+15].copy()
        vis_r_2 = self.visRcp[self.frequencyChannel,self.calibIndex,512+15+31:512+15+31+14].copy()
        vis_r_1 *= NP.sqrt(self.ampRcp[self.frequencyChannel,self.calibIndex,0:15]*self.ampRcp[self.frequencyChannel,self.calibIndex,1:16])
        vis_r_2 *= NP.sqrt(self.ampRcp[self.frequencyChannel,self.calibIndex,0:14]*self.ampRcp[self.frequencyChannel,self.calibIndex,2:16])
        ls_res = least_squares(self.sGainsFunc, x_ini, args = (vis_r_1, vis_r_2))
        sGainsRcp = ls_res['x'][2:18] + ls_res['x'][20:]*1j
        self.sAntPhaRcp = NP.angle(sGainsRcp)
        self.sAntAmpRcp = NP.abs(sGainsRcp)
        
    def updateEwGains(self):
        x_ini = NP.concatenate((NP.ones(34), NP.zeros(34)))
        vis_l_1 = self.visLcp[self.frequencyChannel,self.calibIndex,512+15:512+15+31].copy()
        vis_l_2 = self.visLcp[self.frequencyChannel,self.calibIndex,512+15+31+14:512+15+31+14+30].copy()
        vis_l_1 *= NP.sqrt(self.ampLcp[self.frequencyChannel,self.calibIndex,16:-1]*self.ampLcp[self.frequencyChannel,self.calibIndex,17:])
        vis_l_2 *= NP.sqrt(self.ampLcp[self.frequencyChannel,self.calibIndex,16:-2]*self.ampLcp[self.frequencyChannel,self.calibIndex,18:])
        ls_res = least_squares(self.ewGainsFunc, x_ini, args = (vis_l_1, vis_l_2))
        ewGainsLcp = ls_res['x'][2:34] + ls_res['x'][36:]*1j
        self.ewAntPhaLcp = NP.angle(ewGainsLcp)
        self.ewAntAmpLcp = NP.abs(ewGainsLcp)
        
        vis_r_1 = self.visRcp[self.frequencyChannel,self.calibIndex,512+15:512+15+31].copy()
        vis_r_2 = self.visRcp[self.frequencyChannel,self.calibIndex,512+15+31+14:512+15+31+14+30].copy()
        vis_r_1 *= NP.sqrt(self.ampRcp[self.frequencyChannel,self.calibIndex,16:-1]*self.ampRcp[self.frequencyChannel,self.calibIndex,17:])
        vis_r_2 *= NP.sqrt(self.ampRcp[self.frequencyChannel,self.calibIndex,16:-2]*self.ampRcp[self.frequencyChannel,self.calibIndex,18:])
        ls_res = least_squares(self.ewGainsFunc, x_ini, args = (vis_r_1, vis_r_2))
        ewGainsRcp = ls_res['x'][2:34] + ls_res['x'][36:]*1j
        self.ewAntPhaRcp = NP.angle(ewGainsRcp)
        self.ewAntAmpRcp = NP.abs(ewGainsRcp)
        
    def setCalibIndex(self, calibIndex):
        self.calibIndex = calibIndex;
        if self.useNonlinearApproach:
            self.updateSGains()
            self.updateEwGains()
        else:
            if self.phaseCalibFull:
                self.updateAntennaPhaseFull()
            else:
                self.updateAntennaPhase()
                
            if self.updateAmpCalibration:
                self.updateAntennaAmplitude()

    def setFrequencyChannel(self, channel):
        self.frequencyChannel = channel
        if self.useNonlinearApproach:
            self.updateSGains()
            self.updateEwGains()
        else:
            if self.phaseCalibFull:
                self.updateAntennaPhaseFull()
            else:
                self.updateAntennaPhase()
            self.updateAntennaAmplitude()
        
    def changeEastWestPhase(self, newLcpPhaseCorrection, newRcpPhaseCorrection):
        self.ewLcpPhaseCorrection[:] = newLcpPhaseCorrection[:]
        self.ewRcpPhaseCorrection[:] = newRcpPhaseCorrection[:]
        
    def changeSouthPhase(self, newLcpPhaseCorrection, newRcpPhaseCorrection):
        self.sLcpPhaseCorrection[:] = newLcpPhaseCorrection[:]
        self.sRcpPhaseCorrection[:] = newRcpPhaseCorrection[:]
        
    def calculateDelays(self):
        self.sDelays = NP.zeros((16, self.dataLength))
        self.ewDelays = NP.zeros((32, self.dataLength))
        base = 4.9
        ew_center = 64.5
        ns_center = 192.5
        _PHI = 0.903338787600965
        for scan in range(self.dataLength):
            hourAngle = self.omegaEarth * (self.freqTime[self.frequencyChannel, scan] - self.RAO.culmination)
            dec = self.getDeclination()
            for ant in range(16):
                cosQ = NP.cos(hourAngle) * NP.cos(dec)*NP.sin(_PHI) - NP.sin(dec)*NP.cos(_PHI);
                M = ns_center - 192 + ant;
                self.sDelays[ant, scan] = base * M * cosQ / constants.c.to_value();
            for ant in range(32):
                cosP = NP.sin(hourAngle) * NP.cos(dec);
                N = ew_center - ant - 49;
                self.ewDelays[ant, scan] = base * N * cosP / constants.c.to_value();

    def vis2uv(self,  scan, phaseCorrect = False, amplitudeCorrect = False, PSF = False, ewCoef = 1., sCoef = 1., average = 0):
        self.uvLcp[:,:] = complex(0,0)
        self.uvRcp[:,:] = complex(0,0)
        O = self.sizeOfUv//2 + 1
        if PSF == False:
            if average == 0:
                for jj in range(16):
                    for ii in range(32):
                      self.uvLcp[O + jj*2, O + (ii - 16)*2] = self.visLcp[self.frequencyChannel, scan, jj*32 + ii]
                      self.uvLcp[O + jj*2, O + (ii - 16)*2] *= 0.01*NP.sqrt(self.ampLcp[self.frequencyChannel,scan,ii + 16] * self.ampLcp[self.frequencyChannel,scan,jj])
                      self.uvRcp[O + jj*2, O + (ii - 16)*2] = self.visRcp[self.frequencyChannel, scan, jj*32 + ii]
                      self.uvRcp[O + jj*2, O + (ii - 16)*2] *= 0.01*NP.sqrt(self.ampRcp[self.frequencyChannel,scan,ii + 16] * self.ampRcp[self.frequencyChannel,scan,jj])
                      self.uvLcp[O - 2 - jj*2, O + (15 - ii)*2] = NP.conj(self.uvLcp[O + jj*2, O + (ii - 16)*2])
                      self.uvRcp[O - 2 - jj*2, O + (15 - ii)*2] = NP.conj(self.uvRcp[O + jj*2, O + (ii - 16)*2])
            else:
                firstScan = scan
                if  self.visLcp.shape[1] < (scan + average):
                    lastScan = self.dataLength
                else:
                    lastScan = scan + average
                for jj in range(16):
                    for ii in range(32):
                      self.uvLcp[O + jj*2, O + (ii - 16)*2] = NP.mean(self.visLcp[self.frequencyChannel, firstScan:lastScan, jj*32 + ii] * 0.01*NP.sqrt(self.ampLcp[self.frequencyChannel,firstScan:lastScan,ii + 16] * self.ampLcp[self.frequencyChannel,firstScan:lastScan,jj]))
#                      self.uvLcp[O + jj*2, O + (ii - 16)*2] *= 0.01*NP.sqrt(self.ampLcp[self.frequencyChannel,scan,ii + 16] * self.ampLcp[self.frequencyChannel,scan,jj])
                      self.uvRcp[O + jj*2, O + (ii - 16)*2] = NP.mean(self.visRcp[self.frequencyChannel, firstScan:lastScan, jj*32 + ii] * 0.01*NP.sqrt(self.ampRcp[self.frequencyChannel,firstScan:lastScan,ii + 16] * self.ampRcp[self.frequencyChannel,firstScan:lastScan,jj]))
#                      self.uvRcp[O + jj*2, O + (ii - 16)*2] *= 0.01*NP.sqrt(self.ampRcp[self.frequencyChannel,scan,ii + 16] * self.ampRcp[self.frequencyChannel,scan,jj])
                      self.uvLcp[O - 2 - jj*2, O + (15 - ii)*2] = NP.conj(self.uvLcp[O + jj*2, O + (ii - 16)*2])
                      self.uvRcp[O - 2 - jj*2, O + (15 - ii)*2] = NP.conj(self.uvRcp[O + jj*2, O + (ii - 16)*2])
                      
            if (phaseCorrect):
                for jj in range(16):
                    for ii in range(32):
                        self.uvLcp[O + jj*2, O + (ii - 16)*2] *= NP.exp(1j*((self.ewAntPhaLcp[ii] + self.ewLcpPhaseCorrection[ii]) - (self.sAntPhaLcp[jj]) + self.sLcpPhaseCorrection[jj]))
                        self.uvRcp[O + jj*2, O + (ii - 16)*2] *= NP.exp(1j*((self.ewAntPhaRcp[ii] + self.ewRcpPhaseCorrection[ii]) - (self.sAntPhaRcp[jj]) + self.sRcpPhaseCorrection[jj]))
                        self.uvLcp[O - 2 - jj*2, O + (15 - ii)*2] = NP.conj(self.uvLcp[O + jj*2, O + (ii - 16)*2])
                        self.uvRcp[O - 2 - jj*2, O + (15 - ii)*2] = NP.conj(self.uvRcp[O + jj*2, O + (ii - 16)*2])
            if (amplitudeCorrect):
                for jj in range(16):
                    for ii in range(32):
                        self.uvLcp[O + jj*2, O + (ii - 16)*2] /= (self.ewAntAmpLcp[ii] * self.sAntAmpLcp[jj])
                        if not self.useDoubleBaselinesAmp:
                            if ii%2 == 0:
                                self.uvLcp[O + jj*2, O + (ii - 16)*2] /= ewCoef
                            if jj%2 == 0:
                                self.uvLcp[O + jj*2, O + (ii - 16)*2] /= sCoef
                        self.uvRcp[O + jj*2, O + (ii - 16)*2] /= (self.ewAntAmpRcp[ii] * self.sAntAmpRcp[jj])
                        self.uvLcp[O - 2 - jj*2, O + (15 - ii)*2] = NP.conj(self.uvLcp[O + jj*2, O + (ii - 16)*2])
                        self.uvRcp[O - 2 - jj*2, O + (15 - ii)*2] = NP.conj(self.uvRcp[O + jj*2, O + (ii - 16)*2])
            if (self.fringeStopping):
                for jj in range(16):
                    for ii in range(32):
                        self.uvLcp[O + jj*2, O + (ii - 16)*2] *= NP.exp(1j * 2*NP.pi*self.freqList[self.frequencyChannel]*1e6 * (-self.sDelays[jj, scan] + self.ewDelays[ii, scan]))
                        self.uvRcp[O + jj*2, O + (ii - 16)*2] *= NP.exp(1j * 2*NP.pi*self.freqList[self.frequencyChannel]*1e6 * (-self.sDelays[jj, scan] + self.ewDelays[ii, scan]))
#                        self.uvLcp[O + jj*2, O + (ii - 16)*2] *= NP.exp(1j * 2*NP.pi*self.freqList[self.frequencyChannel-2]*1e6 * (-self.sDelays[jj, scan] + self.ewDelays[ii, scan]))
#                        self.uvRcp[O + jj*2, O + (ii - 16)*2] *= NP.exp(1j * 2*NP.pi*self.freqList[self.frequencyChannel-2]*1e6 * (-self.sDelays[jj, scan] + self.ewDelays[ii, scan]))
#                        self.uvLcp[O + jj*2, O + (ii - 16)*2] *= NP.exp(1j * 2*NP.pi*self.freqList[self.frequencyChannel]*1e6 * (self.sDelays[jj, scan] - self.ewDelays[ii, scan]))
#                        self.uvRcp[O + jj*2, O + (ii - 16)*2] *= NP.exp(1j * 2*NP.pi*self.freqList[self.frequencyChannel]*1e6 * (self.sDelays[jj, scan] - self.ewDelays[ii, scan]))
                        self.uvLcp[O - 2 - jj*2, O + (15 - ii)*2] = NP.conj(self.uvLcp[O + jj*2, O + (ii - 16)*2])
                        self.uvRcp[O - 2 - jj*2, O + (15 - ii)*2] = NP.conj(self.uvRcp[O + jj*2, O + (ii - 16)*2])
                
        else:
            for jj in range(16):
                for ii in range(32):
                  self.uvLcp[O + jj*2, O + (ii - 16)*2] = .01 + 0j
                  self.uvRcp[O + jj*2, O + (ii - 16)*2] = .01 + 0j
                  self.uvLcp[O - 2 - jj*2, O + (15 - ii)*2] = NP.conj(self.uvLcp[O + jj*2, O + (ii - 16)*2])
                  self.uvRcp[O - 2 - jj*2, O + (15 - ii)*2] = NP.conj(self.uvRcp[O + jj*2, O + (ii - 16)*2])
            if (phaseCorrect):
                for jj in range(16):
                    for ii in range(32):
                        self.uvRcp[O + jj*2, O + (ii - 16)*2] *= NP.exp(1j*((-self.ewAntPhaRcp[ii] - self.ewRcpPhaseCorrection[ii]) + (self.sAntPhaRcp[jj]) + self.sRcpPhaseCorrection[jj]))
                        self.uvRcp[O - 2 - jj*2, O + (15 - ii)*2] = NP.conj(self.uvRcp[O + jj*2, O + (ii - 16)*2])
            if (amplitudeCorrect):
                for jj in range(16):
                    for ii in range(32):
                        self.uvRcp[O + jj*2, O + (ii - 16)*2] *= (self.ewAntAmpRcp[ii] * self.sAntAmpRcp[jj])
                        self.uvRcp[O - 2 - jj*2, O + (15 - ii)*2] = NP.conj(self.uvRcp[O + jj*2, O + (ii - 16)*2])

    def uv2lmImage(self):
        self.lcp = NP.fft.fft2(NP.roll(NP.roll(self.uvLcp,self.sizeOfUv//2,0),self.sizeOfUv//2,1));
        self.lcp = NP.roll(NP.roll(self.lcp,self.sizeOfUv//2,0),self.sizeOfUv//2,1);
        self.rcp = NP.fft.fft2(NP.roll(NP.roll(self.uvRcp,self.sizeOfUv//2,0),self.sizeOfUv//2,1));
        self.rcp = NP.roll(NP.roll(self.rcp,self.sizeOfUv//2,0),self.sizeOfUv//2,1);
        
    def ij2hd(self, ij):
        return(((ij[0] - self.centerH)*self.deltaH,(ij[1] - self.centerD)*self.deltaD));

    def hd2pq(self, hd):
        return((hd[0],hd[1]));

    def pq2kl(self, pq):
        return((pq[0]/self.deltaP + self.centerP,pq[1]/self.deltaQ + self.centerQ));

    def ij2kl(self, ij):
        return(self.pq2kl(self.hd2pq(self.ij2hd(ij))));
        
    def lmImage2hdImage(self):
        return(ndimage.geometric_transform(self.lcp.real,self.ij2kl));
    
    def getDateObs(self):
        return self.dateObs if self.isOpen else ''

    def getDataLength(self):
        return self.dataLength if self.isOpen else 0

    def getTimesObs(self):
        return self.hduList[1].data['TIME'] if self.isOpen else 0

    def getAntennaA(self):
        return self.antennaA if self.isOpen else 0
        
    def getAntennaB(self):
        return self.antennaB if self.isOpen else 0

    def getVisLcp(self):
        return self.visLcp if self.isOpen else 0
        
    def getVisRcp(self):
        return self.visRcp if self.isOpen else 0
    
    def getFrequencyList(self):
        return self.freqList
    
    def phaseClosure(self, antA, antB, antC):
        pC = NP.zeros(self.dataLength)
        for i in range(self.dataLength):
            pC[i] = NP.angle(self.visLcp[5,i,antA]) + NP.angle(self.visLcp[5,i,antB]) - NP.angle(self.visLcp[5,i,antC])
        return pC

    def phaseAnt(self, antA):
        pC = NP.zeros(self.dataLength)
        for i in range(self.dataLength):
            pC[i] = NP.angle(self.visLcp[5,i,antA]) 
        return pC

    def magnitAnt(self, antA):
        pC = NP.zeros(self.dataLength)
        for i in range(self.dataLength):
            pC[i] = NP.abs(self.visLcp[5,i,antA]) 
        return pC

    def phaseClosureSouthVector(self, visEw, scan, freq):
        pC = NP.zeros(16)
        for i in range(15):
            pC[i + 1] = NP.angle(self.visLcp[freq,scan,512 + 15 + visEw]) + NP.angle(self.visLcp[freq,scan,32*i + visEw + 1]) - NP.angle(self.visLcp[freq,scan,32*i + visEw])
        return pC

    def phaseClosureEastWestVector(self, visS, scan, freq):
        pC = NP.zeros(32)
        pC[0] = 1.
        for i in range(31):
            pC[i + 1] = - NP.angle(self.visLcp[freq,scan,16*visS + i]) + NP.angle(self.visLcp[freq,scan,512 + visS]) - NP.angle(self.visLcp[freq,scan,16*visS + i + 1]) 
        return pC
    
    def solveSouthPhaseClosure(self, pcVector):
        phases, c, d, e = NP.linalg.lstsq(self.sPhaseClosureMatrix,pcVector);
        return phases

    def solveEastWestPhaseClosure(self, pcVector):
        phases, c, d, e = NP.linalg.lstsq(self.ewPhaseClosureMatrix,pcVector);
        return phases
    